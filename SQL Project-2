SUB PROJECT 1 :

DROP TABLE IF EXISTS students_2023;
CREATE TABLE students_2023 (
		student_id SERIAL PRIMARY KEY,
		student_name VARCHAR (100),
		course VARCHAR(100)
);
SELECT * FROM students_2023;

INSERT INTO students_2023(student_name, course) VALUES 
('Aarav Sharma','computer science'),
('Ishita Verma', 'Mechanical Engineering'),
('Kabir Patel', 'Electronics'),
('Ananya Desai', 'Civil Engineering'),
('Rahul Gupta', 'Computer Science');

DROP TABLE IF EXISTS students_2024;
CREATE TABLE students_2024 (
    student_id INT PRIMARY KEY,
    student_name VARCHAR(100),
    course VARCHAR(50)
);

INSERT INTO students_2024 (student_id, student_name, course) VALUES
(3, 'Kabir Patel', 'Electronics'),   -- Same as students_2023
(4, 'Ananya Desai', 'Civil Engineering'), -- Same as students_2023
(6, 'Meera Rao', 'Computer Science'),
(7, 'Vikram Singh', 'Mathematics'),
(8, 'Sanya Kapoor', 'Physics');


SELECT * FROM students_2024;

-- UNION -- Combines results, removes duplicates
SELECT student_name, course 
FROM students_2023
UNION
SELECT student_name, course
FROM students_2024;


-- UNION ALL - Combines results, keeps duplicates
SELECT student_name, course 
FROM students_2023
UNION ALL
SELECT student_name, course
FROM students_2024;


-- INTERSECT - Returns common results in both tables
SELECT student_name, course 
FROM students_2023
INTERSECT
SELECT student_name, course
FROM students_2024;


-- EXCEPT  -- Returns results in the first table but not in the second

SELECT student_name, course 
FROM students_2023
EXCEPT
SELECT student_name, course
FROM students_2024;



SUB PROJECT 2 :

DROP TABLE IF EXISTS products;
CREATE TABLE products(
product_id SERIAL PRIMARY KEY,
product_name VARCHAR(100),
category VARCHAR(100),
price NUMERIC(10,2),
quantity INT,
added_date DATE,
discount_rate NUMERIC(5,2)
);

SELECT * FROM products;

INSERT INTO products (product_name, category, price, quantity, added_date, discount_rate) VALUES
('Laptop', 'Electronics', 75000.50, 10, '2024-01-15', 10.00),
('Smartphone', 'Electronics', 45000.99, 25, '2024-02-20', 5.00),
('Headphones', 'Accessories', 1500.75, 50, '2024-03-05', 15.00),
('Office Chair', 'Furniture', 5500.00, 20, '2023-12-01', 20.00),
('Desk', 'Furniture', 8000.00, 15, '2023-11-20', 12.00),
('Monitor', 'Electronics', 12000.00, 8, '2024-01-10', 8.00),
('Printer', 'Electronics', 9500.50, 5, '2024-02-01', 7.50),
('Mouse', 'Accessories', 750.00, 40, '2024-03-18', 10.00),
('Keyboard', 'Accessories', 1250.00, 35, '2024-03-18', 10.00),
('Tablet', 'Electronics', 30000.00, 12, '2024-02-28', 5.00);


SELECT * FROM products;

-- Total Quantity Available of all products
SELECT SUM(quantity) AS total_quantity 
FROM products;

SELECT SUM(price) AS total_price FROM products;

SELECT SUM(quantity) AS quantity_of_ele
FROM products
WHERE category='Electronics' AND price > 20000 ;

SELECT SUM(price) AS quantity_of_fur
FROM products
WHERE category='Furniture';

-- Total number of products

SELECT COUNT(*) AS total_products
FROM products;

-- count with condition

SELECT COUNT(*) AS total_products
FROM products
WHERE product_name LIKE '%phone%';


-- Average Price of Products
SELECT AVG(price) AS average_price
FROM products;

-- Average Price of Products with condition
SELECT AVG(price) AS average_price
FROM products
WHERE category='Accessories' OR added_date > '2024-02-01';

SELECT * FROM products;


-- Maximum and Minimum price

SELECT MAX(price) AS MAX_PRICE,
		MIN(PRICE) AS MIN_PRICE
FROM products;



SUB PROJECT 3 :

--use of STRING FUNCTION

--Get all categories in upper and lower case
SELECT UPPER(category) AS category_upper
FROM products;

SELECT LOWER(category) AS category_upper
FROM products;

--join product_name and category_name with hypen
SELECT CONCAT(product_name, '-', category) AS product_details
FROM products;

-- Extract the first 5 characters from product_name
SELECT SUBSTRING(product_name, 1,5) AS short_name
FROM products;

-- Count length
SELECT product_name, LENGTH(product_name) AS COUNT_OF_CHAR
FROM products;

--Remove leading and trailing spaces from string
 SELECT LENGTH(TRIM('  Monitor    ')) AS Trimmed_Text;
 SELECT LENGTH('  Monitor    ') AS Trimmed_Text;


-- Replace the word "phone" with "device" in product names
SELECT REPLACE(product_name, 'phone','device') AS updated
FROM products;

-- Get the first 3 characters from category

SELECT RIGHT(category, 3) AS Catergory_Capital
FROM products;

SELECT * from products;



SUB PROJECT 4 :

--DATE & TIME function in SQL

-- 1. NOW() â€“ Get Current Date and Time

SELECT NOW() AS Current_Datetime;


-- 2. CURRENT_DATE() â€“ Get Current Date
SELECT CURRENT_DATE AS today_date;

SELECT Added_date, Current_Date, (CURRENT_DATE- added_date) AS Days_difference
FROM products;


-- 3. EXTRACT() â€“ Extract Parts of a Date
-- Extract the year, month, and day from the added_date column.

SELECT product_name,
		EXTRACT(YEAR FROM added_date) AS Year_Added,
		EXTRACT(MONTH FROM added_date) AS Month_Added,
		EXTRACT(DAY FROM added_date) AS Day_Added
FROM products;


-- 4. AGE() â€“ Calculate Age Between Dates
-- Calculate the time difference between added_date and todayâ€™s date.

SELECT product_name,
	AGE(CURRENT_DATE, added_date) AS Age_since_added
FROM products;
  	

-- 5. TO_CHAR() â€“ Format Dates as Strings
-- Format added_date in a custom format (DD-Mon-YYYY).

SELECT product_name,
	TO_CHAR(added_date, 'DD-Mon-YYYY') AS FORMATED_DATE
FROM products;

-- 6. DATE_PART() â€“ Get Specific Date Part
-- Extract the day of the week from added_date.

SELECT product_name, added_date,
		DATE_PART('year', added_date) AS day_of_week
FROM products;

SELECT product_name, added_date,
		DATE_PART('month', added_date) AS day_of_week
FROM products;

SELECT product_name, added_date,
		DATE_PART('days', added_date) AS day_of_week
FROM products;


-- 7. DATE_TRUNC() â€“ Truncate Date to Precision
-- Truncate added_date to the start of the month.


SELECT product_name, added_date,
		DATE_TRUNC('week', added_date) AS week_start,
		DATE_PART('isodow', added_date) AS day_of_week
FROM products;


-- 8. INTERVAL â€“ Add or Subtract Time Intervals
-- Add 6 months to the added_date.

SELECT product_name, added_date,
		added_date + INTERVAL '6 months' AS new_date
FROM products;


--NOTE :SELECT 
    DATE_PART('year', CURRENT_DATE) AS year,
    DATE_PART('month', CURRENT_DATE) AS month,
    DATE_PART('dow', CURRENT_DATE) AS day_of_week,
    DATE_PART('doy', CURRENT_DATE) AS day_of_year,
    DATE_PART('week', CURRENT_DATE) AS week_number;

--ðŸ“… Common date_part Fields
date_part	Description	Example (from '2025-04-13')
year	        Extracts the year	2025
month	        Extracts the month (1â€“12)	4
day	        Extracts the day of the month	13
hour	        Extracts the hour (0â€“23)	0 (if no time provided)
minute	        Extracts the minute (0â€“59)	0
second	        Extracts the second (0â€“59.999...)	0.00
dow	        Day of week (0 = Sunday, 6 = Saturday)	0 (for Sunday)
doy	        Day of year (1â€“366)	103
week	        Week number of the year (1â€“53)	15
quarter	        Quarter of the year (1â€“4)	2
epoch	        Number of seconds since 1970-01-01	timestamp to seconds
decade	        Extracts the decade	202 (for 2025)
century	        Extracts the century	21 (for 2025)
millennium	Extracts the millennium	3
timezone	Time zone offset in seconds	Depends on setting
timezone_hour	Hour part of time zone offset	Depends
timezone_minute	Minute part of time zone offset	Depends



SUB PROJECT 5 :

/* 1. CASE Function â€“ Categorizing Based on Conditions
 We will categorize products into price ranges:

Expensive if the price is greater than or equal to 50,000.
Moderate if the price is between 10,000 and 49,999.
Affordable if the price is less than 10,000.
*/

SELECT product_name, price,
		CASE
			WHEN price>=50000 THEN 'Expensive'
			WHEN price>=10000 AND price<=49999 THEN 'Moderate'
			ELSE 'Affordable'
		END AS price_category
FROM products;


/* 2. CASE with AND & OR Operators â€“ Stock Status
We will classify products based on quantity available:

In Stock if quantity is 10 or more.
Limited Stock if quantity is between 5 and 9.
Out of Stock Soon if quantity is less than 5.
*/

SELECT product_name, quantity, 
		CASE
			WHEN quantity >=10 THEN 'InStock'
			WHEN quantity BETWEEN 6 AND 9 THEN 'Limited stock'
			ELSE 'Out of stock soon'
		END AS stock_status
FROM products;


/* 3. CASE with LIKE Operator â€“ Category Classification
Check if the category name contains "Electronics" or "Furniture" using LIKE.
*/


SELECT product_name, category, 
		CASE
			WHEN category LIKE 'Electronics%' THEN 'Electronic Item'
			WHEN category LIKE 'Furniture%' THEN 'Furniture Item'
			ELSE 'Accessory Item'
		END AS category_Status
FROM products;


--To handle NULL value we use COALESCE function

SELECT * FROM products;


ALTER TABLE products 
ADD COLUMN discount_price NUMERIC(10,2);

UPDATE products
SET discount_price = price*0.9
WHERE product_name NOT IN('Laptop','Desk');

ALTER TABLE products
DROP COLUMN discount_price;

SELECT product_name, price, discount_price 
FROM products;

SELECT product_name, 
		COALESCE(discount_price, price) AS Final_price
FROM products;



SUB PROJECT 6 :

--WINDOWS FUNCTION

-- Assign a unique row number to each product within the same category.

SELECT product_name, category, price,
		ROW_NUMBER() OVER(PARTITION BY category ORDER BY price DESC) AS Ranking
FROM products;

--					OR

SELECT product_name, category, price,
		DENSE_RANK() OVER(PARTITION BY category ORDER BY price DESC) AS Ranking
FROM products;

--					OR
--DRAWBACK OF RANK (We may miss ranking if their are 2 same price products)

SELECT product_name, category, price,
		RANK() OVER(PARTITION BY category ORDER BY price DESC) AS Ranking
FROM products;

--Running Total
SELECT product_name, category, price,
		sum(price) OVER(PARTITION BY category ORDER BY price ASC) AS Running_Total
FROM products;

--					OR
SELECT product_name, category, price,
		sum(price) OVER(ORDER BY price ASC) AS Running_Total
FROM products;

SELECT product_name, category, price,
		AVG(price) OVER(PARTITION BY category ORDER BY price ASC) AS Running_Total
FROM products;



SUB PROJECT 7 :

--JOINS IN SQL :

-- Create Employees Table

DROP TABLE IF EXISTS Employees3;
CREATE TABLE Employees3 (
    employee_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    department_id INT
);

SELECT * FROM Employees3;

-- Insert Data into Employees
INSERT INTO Employees3 (first_name, last_name, department_id)
VALUES
('Rahul', 'Sharma', 101),
('Priya', 'Mehta', 102),
('Ankit', 'Verma', 103),
('Simran', 'Kaur', NULL),
('Aman', 'Singh', 101);

SELECT * FROM employees3;

-- Create Departments Table
CREATE TABLE Departments (
    department_id INT PRIMARY KEY,
    department_name VARCHAR(50)
);

SELECT * FROM Departments;

-- Insert Data into Departments
INSERT INTO Departments (department_id, department_name)
VALUES
(101, 'Sales'),
(102, 'Marketing'),
(103, 'IT'),
(104, 'HR');


SELECT * FROM Departments;

--INNER JOIN - retrive Employees3 and their department names where a match exists

SELECT e.employee_id, e.first_name, e.last_name, 
		d.department_id, d.department_name 
FROM Employees3 e 
RIGHT JOIN
Departments d
ON e.department_id=d.department_id;

--LEFT JOIN - retrive all Employees3 data (left table...all data) and the data from department table which matches with  the left one (Left table is employees3 table and right table is depratment table )

SELECT e.employee_id, e.first_name, e.last_name, 
		d.department_id, d.department_name 
FROM Employees3 e 
LEFT JOIN
Departments d
ON e.department_id=d.department_id;

--RIGHT JOIN

SELECT e.employee_id, e.first_name, e.last_name, 
		d.department_id, d.department_name 
FROM Employees3 e 
RIGHT JOIN
Departments d
ON e.department_id=d.department_id;

--FULL OUTER JOIN : retrive all the data from both the tables

SELECT e.employee_id, e.first_name, e.last_name, 
		d.department_id, d.department_name 
FROM Employees3 e 
FULL OUTER JOIN
Departments d
ON e.department_id=d.department_id;

--CROSS JOIN : retrive all possible combinations of employees3 and department

SELECT e.first_name, e.last_name, d.department_name
FROM employees3 e
CROSS JOIN 
	Departments d;

--SELF JOIN : Find Employees3 who share the same department

SELECT e1.first_name AS Employee_name1,
	   e2.first_name AS Employee_name2,
	   d.department_name
FROM employees3 e1 JOIN employees3 e2
ON e1.department_id=e2.department_id AND e1.employee_id!=e2.employee_id
JOIN 
departments d
ON	
e1.department_id=d.department_id;

